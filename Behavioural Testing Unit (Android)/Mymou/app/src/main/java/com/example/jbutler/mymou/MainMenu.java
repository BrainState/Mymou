package com.example.jbutler.mymou;

import android.Manifest;
import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.FragmentManager;
import android.app.FragmentTransaction;
import android.app.PendingIntent;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.UUID;

public class MainMenu extends Activity implements Thread.UncaughtExceptionHandler {

    private static TaskExample task = new TaskExample();
    public static final boolean testingMode = false;

    //Bluetooth variables
    public static int monkeyId = -1;
    private static final int REQUEST_ENABLE_BT = 1;
    private BluetoothAdapter btAdapter = null;
    private BluetoothSocket btSocket = null;
    private static OutputStream outStream = null;
    private boolean btReceiversRegistered = false;
    public static boolean bluetoothStatus = false;
    private static String allChanOff, chanZeroOn, chanZeroOff, chanOneOn, chanOneOff, chanTwoOn,
            chanTwoOff, chanThreeOn, chanThreeOff;
    // Replace with your devices UUID and address
    private static final UUID MY_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
    private static String address = "20:16:06:08:64:22";

    //Permission variables
    final private int REQUEST_CODE_WRITE_PERMISSION = 123;
    final private int REQUEST_CODE_CAMERA_PERMISSION = 456;
    private boolean permissions = false;

    private static FaceRecog faceRecog;
    public static String message;
    private static Handler logHandler;
    private static HandlerThread logThread;
    private FragmentManager fragmentManager;
    private FragmentTransaction fragmentTransaction;

    @Override
    public void uncaughtException(Thread thread, Throwable throwable) {
        logHandler.post(new CrashReport(throwable));
        quitBt();
        restartApp();
    }

    private void restartApp() {
        Intent intent=new Intent(getApplicationContext(), MainMenu.class);
        intent.putExtra("restart",true);
        final PendingIntent pendingIntent = PendingIntent.getActivity(
                getApplicationContext(),
                0, intent, PendingIntent.FLAG_ONE_SHOT);
        AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent);
        System.exit(2);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main_menu);

        initialiseBluetooth();

        initialiseLayoutParameters();

        initialiseScreenSetttings();

        checkPermissions();

        initialiseRewardChannels();

        Thread t = new Thread(new Runnable() {
            public void run() {
                // Enable this to enable the facial recognition
                // Must have the corresponding .txt files present generated by the python ANN module
                // present in the Mymou folder in the root directory of the Android device
                //faceRecog = new FaceRecog();
            }
        });
        t.start();

        registerPowerReceivers();

        logThread = new HandlerThread("LogBackground");
        logThread.start();
        logHandler = new Handler(logThread.getLooper());

        this.startLockTask();

        fragmentManager = getFragmentManager();
        fragmentTransaction = fragmentManager.beginTransaction();

        checkIfCrashed();

        if(testingMode) {
            startTask();
        } else {
            // Enable this if you want task to automatically restart on crash
            //Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
                //@Override
              //  public void uncaughtException(Thread thread, Throwable throwable) {
              //      logHandler.post(new CrashReport(throwable));
                //    quitBt();
                    //restartApp();
                //}
            //});
        }
    }

    private void checkIfCrashed() {
        Bundle extras = getIntent().getExtras();
        if(extras !=null) {
            if (extras.getBoolean("restart") == true) {
                //If crashed then restart task
                if(bluetoothStatus) {
                    registerBluetoothReceivers();
                } else {
                    reconnectBluetooth();
                }
                startTask();
            }
        }
    }

    private void registerPowerReceivers() {
        IntentFilter unplugIntent = new IntentFilter(Intent.ACTION_POWER_DISCONNECTED);
        IntentFilter plugIntent = new IntentFilter(Intent.ACTION_POWER_CONNECTED);
        registerReceiver(powerPlugReceiver, plugIntent);
        registerReceiver(powerUnplugReceiver, unplugIntent);
    }

    private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            switch (action){
                case BluetoothDevice.ACTION_ACL_CONNECTED:
                    //Bluetooth connected
                    task.enableApp(true);
                    break;
                case BluetoothDevice.ACTION_ACL_DISCONNECTED:
                    //Bluetooth disconnected
                    bluetoothStatus = false;
                    task.enableApp(false);
                    reconnectBluetooth();
                    break;
            }
        }
    };


    private void initialiseRewardChannels(){
        allChanOff = getString(R.string.allChanOff);
        chanZeroOn = getString(R.string.chanTwoOn);
        chanZeroOff = getString(R.string.chanTwoOff);
        chanOneOn = getString(R.string.chanThreeOn);
        chanOneOff = getString(R.string.chanThreeOff);
        chanTwoOn = getString(R.string.chanFourOn);
        chanTwoOff = getString(R.string.chanFourOff);
        chanThreeOn = getString(R.string.chanFiveOn);
        chanThreeOff = getString(R.string.chanFiveOff);
    }

    private final BroadcastReceiver powerPlugReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if(action.equals(Intent.ACTION_POWER_CONNECTED)) {
                // Do something when power connected
                //task.enableApp();
            }
        }
    };

    private final BroadcastReceiver powerUnplugReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if(action.equals(Intent.ACTION_POWER_DISCONNECTED)) {
                // Do something when power disconnected
                //task.disableApp();
            }
        }
    };


    private void checkPermissions() {
        // Check that writing to storage and camera permissions are enabled
        // Don't need permission for Bluetooth
        boolean checkCameraPermission = checkPermissionNested(Manifest.permission.CAMERA,
                REQUEST_CODE_CAMERA_PERMISSION);
        boolean checkWritePermission = checkPermissionNested(Manifest.permission.WRITE_EXTERNAL_STORAGE,
                REQUEST_CODE_WRITE_PERMISSION);
        if(checkCameraPermission && checkWritePermission) {
            View layout = findViewById(R.id.layoutCoveringUi);
            layout.setVisibility(View.INVISIBLE);
            permissions = true;
        }
    }

    private boolean checkPermissionNested(final String permissionItem, final int permissionCode) {
        int hasWriteContactsPermission = checkSelfPermission(permissionItem);
        if (hasWriteContactsPermission != PackageManager.PERMISSION_GRANTED) {
            if (!shouldShowRequestPermissionRationale(permissionItem)) {
                showMessageOKCancel("You need to allow access for logging to occur",
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                requestPermissions(new String[] {permissionItem},
                                        permissionCode);
                            }
                        });
                return false;
            }
            requestPermissions(new String[] {permissionItem},
                    permissionCode);
            return false;
        } else {
            return true;
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        if(grantResults.length > 0) {
            switch (requestCode) {
                case REQUEST_CODE_CAMERA_PERMISSION:
                    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                        Toast.makeText(this, "Camera permission enabled", Toast.LENGTH_SHORT).show();
                        checkPermissions();
                    } else {
                        // Permission Denied
                        Toast.makeText(this, "Camera permission denied", Toast.LENGTH_SHORT).show();
                    }
                    break;
                case REQUEST_CODE_WRITE_PERMISSION:
                    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                        // Permission Granted
                        Toast.makeText(this, "Write permission enabled", Toast.LENGTH_SHORT).show();
                        checkPermissions();
                    } else {
                        // Permission Denied
                        Toast.makeText(this, "Write to storage denied", Toast.LENGTH_SHORT).show();
                    }
                default:
                    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
            }
        }
    }

    private void showMessageOKCancel(String message, DialogInterface.OnClickListener okListener) {
        new AlertDialog.Builder(this)
                .setMessage(message)
                .setPositiveButton("OK", okListener)
                .setNegativeButton("Cancel", null)
                .create()
                .show();
    }

    private void initialiseLayoutParameters() {
        //Permission buttons
        findViewById(R.id.mainPermButton).setOnClickListener(buttonClickListener);
        findViewById(R.id.buttonCameraPermission).setOnClickListener(buttonClickListener);
        findViewById(R.id.buttonWritePermission).setOnClickListener(buttonClickListener);
        findViewById(R.id.button1).setOnClickListener(buttonClickListener);
        findViewById(R.id.buttonCalibration).setOnClickListener(buttonClickListener);

        initialiseToggleButtons();
    }

    private void initialiseToggleButtons() {
        ToggleButton toggle0 = (ToggleButton) findViewById(R.id.chanZeroButt);
        toggle0.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    startChannel(0);
                } else {
                    stopChannel(0);
                }
            }
        });

        ToggleButton toggle1 = (ToggleButton) findViewById(R.id.chanOneButt);
        toggle1.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    startChannel(1);
                } else {
                    stopChannel(1);
                }
            }
        });

        ToggleButton toggle2 = (ToggleButton) findViewById(R.id.chanTwoButt);
        toggle2.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    startChannel(2);
                } else {
                    stopChannel(2);
                }
            }
        });

        ToggleButton toggle3 = (ToggleButton) findViewById(R.id.chanThreeButt);
        toggle3.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                if (isChecked) {
                    startChannel(3);
                } else {
                    stopChannel(3);
                }
            }
        });
    }

    public static void setMonkeyId(int[] intArray) {
        if (faceRecog != null) {
            monkeyId = faceRecog.idImage(intArray);
        }
    }

    public static void commitTrialData(ArrayList<String> trialData, int outcome, int rewardChosen) {
        if (trialData != null) {
            int length = trialData.size();
            for (int i = 0; i < length; i++) {
                String s = trialData.get(i);
                s = s + ',' + outcome + "," + rewardChosen + ',' + monkeyId;
                logHandler.post(new LogEvent(s));
                Log.d("log", s);
            }
        }
    }

    private void reconnectBluetooth() {
        Handler handlerOne = new Handler();
        handlerOne.postDelayed(new Runnable() {
            @Override
            public void run() {
                if(!bluetoothStatus) {
                    connectToBluetooth();
                    reconnectBluetooth();
                } else {
                    stopAllChannels();
                }
            }
        }, 2000);
    }

    private void initialiseBluetooth() {
        Log.d("tag","Connecting to bluetooth..");
        btAdapter = BluetoothAdapter.getDefaultAdapter();
        checkBTState();
        connectToBluetooth();
    }

    private void initialiseScreenSetttings() {
        this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        final View decorView = MainMenu.this.getWindow().getDecorView();
        decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_IMMERSIVE
                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
    }

    public static void shutdownLoop() {
        final Calendar c = Calendar.getInstance();
        int hour = c.get(Calendar.HOUR);
        int AMPM = c.get(Calendar.AM_PM);
        if (hour >= 7 && AMPM == Calendar.PM) {
            task.enableApp(false);
            boolean restartNextDay = true;
            if(restartNextDay) {
                int day = c.get(Calendar.DAY_OF_WEEK);
                if (day == Calendar.THURSDAY | day == Calendar.FRIDAY | day == Calendar.SATURDAY) {
                    startupLoop();
                }
            }
        } else {
            Handler handlerOne = new Handler();
            handlerOne.postDelayed(new Runnable() {
                @Override
                public void run() {
                    shutdownLoop();
                }
            }, 60000);
        }
    }

    private static void startupLoop() {
        Calendar c = Calendar.getInstance();
        int hour = c.get(Calendar.HOUR);
        int AMPM = c.get(Calendar.AM_PM);
        if (hour >= 7 && AMPM == Calendar.AM) {
                task.enableApp(true);
                shutdownLoop();
        } else {
            Handler handlerOne = new Handler();
            handlerOne.postDelayed(new Runnable() {
                @Override
                public void run() {
                    startupLoop();
                }
            }, 60000);
        }
    }

    private void startTask() {
        setContentView(R.layout.activity_all_tasks);
        CameraMain cM = new CameraMain();
        fragmentTransaction.add(R.id.container, cM);
        fragmentTransaction.add(R.id.container, task);
        fragmentTransaction.commit();
    }

    private void registerBluetoothReceivers() {
        if(bluetoothStatus) {
            btReceiversRegistered = true;
            IntentFilter bluetoothIntent = new IntentFilter();
            bluetoothIntent.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
            bluetoothIntent.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
            registerReceiver(bluetoothReceiver, bluetoothIntent);
        }
    }

    private View.OnClickListener buttonClickListener = new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            switch (view.getId()) {
                case R.id.button1:
                    registerBluetoothReceivers();
                    startTask();
                    break;
                case R.id.buttonCalibration:
                    break;
                case R.id.mainPermButton:
                    Toast.makeText(getApplicationContext(), "Use the buttons below to enable permissions", Toast.LENGTH_SHORT).show();
                    break;
                case R.id.buttonCameraPermission:
                    checkPermissionNested(Manifest.permission.CAMERA,
                            REQUEST_CODE_CAMERA_PERMISSION);
                    break;
                case R.id.buttonWritePermission:
                    checkPermissionNested(Manifest.permission.WRITE_EXTERNAL_STORAGE,
                            REQUEST_CODE_WRITE_PERMISSION);
                    break;
            }
        }
    };

    private void quitBt() {
        if (MainMenu.bluetoothStatus) {
            stopAllChannels();
            try {
                outStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                btSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void connectToBluetooth() {
        // Set up a pointer to the remote node using it's address.
        BluetoothDevice device = btAdapter.getRemoteDevice(address);
        try {
            btSocket = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) {
            Toast.makeText(getBaseContext(), "Error 090", Toast.LENGTH_SHORT).show();
        }

        btAdapter.cancelDiscovery();

        // Establish the connection.  This will block until it connects.
        try {
            btSocket.connect();
            TextView tv1 = (TextView)findViewById(R.id.tvBluetooth);
            Button button1 = (Button)findViewById(R.id.button1);
            if(tv1 != null) {
                tv1.setText("Bluetooth status: Connected");
                button1.setText("START TASK");
            }
            bluetoothStatus = true;
        } catch (IOException e) {
            try {
                btSocket.close();
            } catch (IOException e2) {
                Toast.makeText(getBaseContext(), "Error 091", Toast.LENGTH_SHORT).show();
            }
        }

        // Create data stream to talk to server.
        try {
            outStream = btSocket.getOutputStream();
        } catch (IOException e) {
            Toast.makeText(getBaseContext(), "Error 092", Toast.LENGTH_SHORT).show();
        }
    }

    //No onresume as app is oneShot
    @Override
    public void onResume() { super.onResume(); }

    @Override
    public void onPause() {
        super.onPause();

        if(permissions) {
            quitBt();
        }

        quitThreads();

        unregisterReceivers();

        this.stopLockTask();

        Bundle extras = getIntent().getExtras();
        if(extras != null) {
            if (extras.getBoolean("restart") == true) {
                restartApp();
            }
        }
    }

    private void quitThreads() {
        logThread.quitSafely();
        try {
            logThread.join();
            logThread = null;
            logHandler = null;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void unregisterReceivers() {
        unregisterReceiver(powerPlugReceiver);
        unregisterReceiver(powerUnplugReceiver);
        if(btReceiversRegistered) {
            unregisterReceiver(bluetoothReceiver);
        }
    }

    private void checkBTState() {
        if (btAdapter == null) {
            Toast.makeText(getBaseContext(), "No Bluetooth support found", Toast.LENGTH_SHORT).show();
        } else {
            if (!btAdapter.isEnabled()) {
                //Prompt user to turn on Bluetooth
                Intent enableBtIntent = new Intent(btAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
            }
        }
    }

    public static void stopAllChannels() {
        sendData(allChanOff);
    }

    private static String getStopString(int Ch) {
        String offString="";
        if(Ch == 0) {
            offString = chanZeroOff;
        } else if (Ch == 1) {
            offString = chanOneOff;
        } else if (Ch == 2) {
            offString = chanTwoOff;
        } else if (Ch == 3) {
            offString = chanThreeOff;
        } else {
            Log.d("tag", "Error: No valid Ch specified");
        }
        return offString;
    }

    private static String getStartString(int Ch) {
        String onString="";
        if(Ch == 0) {
            onString = chanZeroOn;
        } else if (Ch == 1) {
            onString = chanOneOn;
        } else if (Ch == 2) {
            onString = chanTwoOn;
        } else if (Ch == 3) {
            onString = chanThreeOn;
        } else {
            Log.d("tag", "Error: Invalid ch specified");
        }
        return onString;
    }

    public static void stopChannel(int Ch) {
        String stopString = getStopString(Ch);
        sendData(stopString);
    }

    public static void startChannel(int Ch) {
        String startString = getStartString(Ch);
        sendData(startString);
    }

    public static void customRewardChannel(final int Ch, int amount) {
        Log.d("tag","Giving reward "+amount+" ms on channel "+Ch);

        startChannel(Ch);

        new CountDownTimer(amount, 100) {
            public void onTick(long ms) {}
            public void onFinish() { stopChannel(Ch); }
        }.start();
    }

    static public void sendData(String message) {
        if(bluetoothStatus) {
            byte[] msgBuffer = message.getBytes();
            try {
                outStream.write(msgBuffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        return false;
    }

    @Override
    public void onBackPressed() {
    }

    @Override
    public boolean onPrepareOptionsMenu (Menu menu) {
        return false;
    }

}